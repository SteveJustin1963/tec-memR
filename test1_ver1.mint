// Memristor Pulse Driver for MINT 2 on TEC-1
// Assumptions:
// - Memristor connected via digital I/O pins (e.g., Z80 PIO or simple latched port)
// - Example port: 0x00 for data output (bit 0 = pulse pin, bit 1 = polarity pin)
// - Polarity: 0 = positive (SET), 1 = negative (RESET)
// - Pulse generated by setting pin high, delay, then low
// - Variables: p = port address, w = pulse width in arbitrary units (longer = wider pulse)
// - Amplitude assumed fixed by hardware (e.g., voltage level set externally)

// Define constants
0 p !          // Output port address (change if needed, e.g. #10 p ! for port 0x10)
0 pol_set !    // Polarity value for SET (low resistance)
1 pol_reset !  // Polarity value for RESET (high resistance)

// Function S: Apply SET pulse (write 'ON' - lower resistance)
// Stack: width --
:S
w !            // Store pulse width
pol_set @p /O  // Set polarity to SET (output to port)
1 p /O         // Set pulse pin high
w ()           // Delay for pulse width
0 p /O         // Set pulse pin low
`SET pulse applied` /N
;

// Function R: Apply RESET pulse (write 'OFF' - higher resistance)
// Stack: width --
:R
w !            
pol_reset @p /O
1 p /O         
w ()           
0 p /O         
`RESET pulse applied` /N
;

// Function D: Read resistance state (non-disturbing short low-amplitude pulse)
// Uses very short pulse + optional /I to sense current (if ADC/hardware available)
// Here: short pulse only (assumes read by external sense or separate circuit)
:D
10 w !         // Short width for read (adjust lower for minimal disturbance)
pol_set @p /O  // Use safe polarity (or dedicated read pin)
1 p /O         
w ()           
0 p /O         
`READ pulse applied` /N
// Optional: /I p to read analog value if port supports input
;

// Example usage (run at > prompt):
// 1000 S     // Strong long SET pulse (width 1000 units)
// 1500 R     // Longer RESET pulse
// D          // Quick read
// 500 5( S ) // Apply 5 incremental SET pulses (for multi-level tuning)

// For neuromorphic-style incremental changes:
:I             // Incremental write function (stack: width count polarity --)
pol ! count ! w !
count (       
  pol @p /O 
  1 p /O    
  w ()      
  0 p /O    
  100 ()    // Small pause between pulses
)
`Incremental pulses done` /N
;

// Example: 300 width, 8 pulses, SET polarity
300 8 0 I
